### Chafer history

Malware used to target iranian-based diplomats: https://securelist.com/chafer-used-remexi-malware/89538/

### IDA Dissassembly

* Sometimes debug data is left in the malware, in this case, DWARF data was left behind, so we have the actual names of all of the functions instead of generated compiled names.
* Pressing command+s gives you access to all of the different sections/segments of the disassembly
	* `.text` is the main section, it has all of the code for the malware
	* `.data` would be for non-code data for the file, like a static string or IP address
* To get cross-references for a pointer, press `X` 

#### Questions
* When a developer's compiler is MSVC cl.exe and they left the debug data in PE, what would you have in your malicious sample? The path to the .pdb file, where the actual names are stored for variables and functions.
* Why is mangling used by the compiler? How could an analyst benefit from "demangling c++ names" usage in IDA? A mangling compiler makes the method names unique. Daemangling them shows the original names; different algorithms for MSVC and GCC compilers.

### Enumerators
When it comes to Windows API calls and incoming parameters, you can go to the IDA enums window, view existing enums, as well as search the windows documentation for a new enum that you might want to add. If you press the `insert` key on the keyboard, you'll get the insert window, press insert based on symbol name, then you'll have a list of all windows API's to choose from and add to the enums window. From there, if you go back to the disassembly view and press `m` on one of the incoming params, you can choose an enum to assign it to.

>When highlighting code instructions, you can press `alt+arrows` to move to the next time that instruction is used in the code.

### `isWin7()` Function

When comparing `al` to something like `eax`, `eax` is usually a return value register in functions, comprised of two `word`'s. `al` is the lower word.

For windows sys internals, the native `GetVersion()` implements a major and minor version number for the OS in the low-order word, and information about the operating system in the high-order word. For all platforms, the low-order word contrains the version number of the OS. The low-order byte of this word specifies the major version number in hex notation. The high-order byte specifies the minor version (revision) number, in hex notation. The high-order bit is zero, the next 7 bits represent the build number, and the low-order byte is 5.

When we have ASM that reads:

```c
public isWin7(void)
isWin7(void) proc near
sub esp, 12             // opens up the stack by 12 bytes
call GetVersion()       // calls windows GetVersion() https://learn.microsoft.com/en-us/windows/win32/api/sysinfoapi/nf-sysinfoapi-getversion
cmp al, 5              // checks the lower order byte for the value of 5 from GetVersion()
setnbe al              // set not below equal to 5, so > 5
add esp, 12            // return stack to normal
movx eax, al           // return value from GetVersion()
retn
isWin7(void) enp
```

Checks version number info: https://learn.microsoft.com/en-us/windows/win32/api/winnt/ns-winnt-osversioninfoexa

Because it's checking for any value greater than 5 in the major version (lower order byte of the lowest word), anything about Windows vista (version 6.0), would return true in `isWin7()`

