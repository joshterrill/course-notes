### Chafer history

Malware used to target iranian-based diplomats: https://securelist.com/chafer-used-remexi-malware/89538/

### IDA Dissassembly

* Sometimes debug data is left in the malware, in this case, DWARF data was left behind, so we have the actual names of all of the functions instead of generated compiled names.
* Pressing command+s gives you access to all of the different sections/segments of the disassembly
	* `.text` is the main section, it has all of the code for the malware
	* `.data` would be for non-code data for the file, like a static string or IP address
* To get cross-references for a pointer, press `X` 
### Cryptographic Windows API's

When looking at Windows API's, a lot of the time the API calls might be mangled. To demangle these names, you can go *Options -> Demangle Names -> Names* and it will give you actual names and parameters as the names of the functions instead of just being in the comments.

We can look through the code for common windows API calls such as `CryptAcquireContextA` and then follow the MS documentation to determine what kind of cryptographic algorithm is being used by this library.

https://learn.microsoft.com/en-us/windows/win32/api/wincrypt/nf-wincrypt-cryptacquirecontexta

`dwProvType` determines the specific cryptographic provider that is being used, of which the types are: https://learn.microsoft.com/en-us/windows/win32/seccrypto/cryptographic-provider-types and we see that the value being passed in is *1*.

**TODO: How do we go from `CryptAcquireContextA` to `CryptDeriveKey`?**

From there we can look for surrounding API's, and we find that `CryptDeriveKey` is being used: https://learn.microsoft.com/en-us/windows/win32/api/wincrypt/nf-wincrypt-cryptderivekey

Where the `AlgId` property being passed in has a hex value of `6801h` which is the RC4 algorithm: https://learn.microsoft.com/en-us/windows/win32/seccrypto/alg-id
### Enumerators
When it comes to Windows API calls and incoming parameters, you can go to the IDA enums window, view existing enums, as well as search the windows documentation for a new enum that you might want to add. If you press the `INSERT` key on the keyboard, you'll get the insert window, press insert based on symbol name, then you'll have a list of all windows API's to choose from and add to the enums window. From there, if you go back to the disassembly view and press `M` on one of the incoming params, you can choose an enum to assign it to.

>When highlighting code instructions, you can press `alt+arrows` to move to the next time that instruction is used in the code.

In this case, if we want to add the RSA_FULL enum to the incoming param of `CryptAcquireContextA`'s `dwProvType` field (which has a value of `1`) we can go to enum, press `INSERT`, then click *Add standard enum by symbol name*, search for the value of `dwProvType = 1` which according to the docs is `PROV_RSA_AES`, press add enum, then we get an enum called `MACRO_PROV` that we can then go back to the API call, press `M`, and assign it the value of `MACRO_PROV` which shows the correct value of the enum in the disassembler.

We can do this for the rest of the incoming params by pressing `M` and assigning them the correct enums for the Windows API's.

### `isUACEnabled` IOC
Looking for other indicators of compromise, we can see after the hashing algorithm finishes it's run, a call to `isUACEnabled(void)` is called where it passes in a value of `31h` into the `Data` parameter, where this is equal to the string of `1` which gets set in a registry key called `SecurityReport` in `\WinLogon`


### `isWin7()` Function

When comparing `al` to something like `eax`, `eax` is usually a return value register in functions, comprised of two `word`'s. `al` is the lower word.

For windows sys internals, the native `GetVersion()` implements a major and minor version number for the OS in the low-order word, and information about the operating system in the high-order word. For all platforms, the low-order word contains the version number of the OS. The low-order byte of this word specifies the major version number in hex notation. The high-order byte specifies the minor version (revision) number, in hex notation. The high-order bit is zero, the next 7 bits represent the build number, and the low-order byte is 5.

When we have ASM that reads:

```c
public isWin7(void)
isWin7(void) proc near
sub esp, 12             // opens up the stack by 12 bytes
call GetVersion()       // calls windows GetVersion() https://learn.microsoft.com/en-us/windows/win32/api/sysinfoapi/nf-sysinfoapi-getversion
cmp al, 5              // checks the lower order byte for the value of 5 from GetVersion()
setnbe al              // set not below equal to 5, so > 5
add esp, 12            // return stack to normal
movx eax, al           // return value from GetVersion()
retn
isWin7(void) enp
```

Checks version number info: https://learn.microsoft.com/en-us/windows/win32/api/winnt/ns-winnt-osversioninfoexa

Because it's checking for any value greater than 5 in the major version (lower order byte of the lowest word), anything about Windows vista (version 6.0), would return true in `isWin7()`

# Questions/Answers

Q1. If a developers’ compiler is MSVC cl.exe and they left debug data, what would you have in your malicious sample?
*The path to .pdb file, where the actual names are stored.*

Q2. Why is name mangling used by the compiler? How could an analyst benefit from “Demangled C++ names” usage?
*A mangling compiler makes the methods names unique. Demangling shows original names; different algorithms for MSVC and gcc compilers.*

Q1. What is the address (RVA) where the crypto context initially acquired algorithms for encryption? _The answer has to be provided in the format of 0x._
*0x40150a*

Q2. Like we did with context creation, please do the same with CryptCreateHash() at 0x401543 to understand the arguments' meaning. What is the algorithm identified
*MD5 or CALG_MD5*

Q3. MD5 algorithm is just for hashing, please use your obtained knowledge to determine the real buffer encryption algorithm.  _In the same function you could start with CryptEncrypt() function._
*RC4 or CALG_RC4*

Q1. Find and move the isUACEnabled() function. Could you provide an indicator of compromise (IoC) to the IR team based on this data?
*The function tries to write “1” to the system registry string value SecurityReport under corresponding Winlogon branch to determine if the user is privileged enough and it’s a good IoC.*

Q2. What does the isWin7() function really check? Does it correspond to the function name?
*Not fully, it checks if the OS is from Vista/Server 2008 and above.*

Q3. In both functions the first instruction subtracts the value from the ESP register. What does it mean?
*Stack frame preparation for local variables.*

# Quiz
Q1. What could be the reason why some symbol names couldn’t be resolved right after the start of the analysis?
*Analysts have to add the corresponding enumerator manually first at enumerators tab.*

Q2. Which prefix would you start to type during the enumerator insertion by symbol name to get the encryption algorithm?
*CALG would be a good option.*

Q3. For what purpose do authors decide to use more than one algorithm from CryptoAPI?
*MD5 is used just to derive RC4 key, so to decrypt buffer data further you would need an initial value for hashing as well as encrypted data.*

