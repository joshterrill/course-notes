## LuckyMouse History
TBD

## Surface-level analysis with FAR

* Open program in HIew / Far Hex Viewer to do surface-level analysis.
* Press F3 to view, and F4 to cycle through modes
* In hex mode, F8 gives you header info, from there F7 gives you imports
* ALT+F6 gives you strings, type in filter to get long strings like `??????*`

When we analyze the LuckyMouse program, looking at the strings, we start to see many strings coming up that have to do with 7zip archives, and then we see a string called `7zS2.sfx` which is a self-extracting archive. When opening this up in IDA, we probably wouldn't get very useful information right away since it's compressed archive, but doing this kind of surface-level analysis at first is a good place to start to gather more information about the malware.

To extract the files from the archive, we press ALT+F2 to select the C:\ drive, then ALT+F6 to rename it by adding a .zip to the end of the filename. Then we can highlight the newly created zip file and press Enter, and we see the contents of it in the editor, looking at files called:

* IntgStat.exe
* pclocalresloader.dll
* thumb.db

We can highlight each of these files and press F5 to copy them back out to the root directory for further analysis.

**Tip: there is basically no difference between a .dll and a .exe, the only difference is a .exe file has a PE header, that's it**

We can view any signed certs by right clicking context menu of the exe file, clicking properties, then going to Digital Signatures, and clicking View Certificate.

Checking the imports, we see some links out to the dll file that exists in the archive.

Checking the strings on the exe, we see some references to pcAnywhere which is a remote desktop tool.

### Static analysis with IDA

Where would we look first for what happens when the dll first gets executed? If we load the dll into IDA, we see that the first function that gets called the starts everything up is the `DllMain()` method.

**TIp: pressing SHIFT+F11 and SHIFT+F5 show you type libraries and signatures, on signatures, you can press INSERT to view list of available library modules, then you can apply them to IDA to help with analysis**

**Tip: In IDA, pressing CTRL+E gives you a list of entry points**

**Tip: Going to Options -> Demangled Names -> Names will move the demangled names out from the comments and put them inline, which may make them easier to read. It's also good to add op-codes to the disassembly by going to Options -> General -> Opcodes -> 6-12**

**Tip: Holding the ALT key and pressing up and down arrows will take you to the ne same instruction as the one currently highlighted**

### Dynamic analysis with x32dbg

To change the default behavior on what events you want to have the debugger break on, go to Options -> Preferences -> Events, and select the events you'd like to break on. It's good to start with just Entry Breakpoint and add more as needed.

When doing dynamic analysis in x32dbg, the address space will be different than IDA. Typically the last 4 bits are going to match, but the first 4 are different, because x32dbg will show the *actual* address space, where IDA will only show the address space starting from the beginning of the PE (0x00). To rebase IDA to match x32dbg, you can go to *Edit -> Segments -> Rebase program* and change the starting image base address to match x32dbg. Make sure to only start the base image with the 4 first bits, let the rest be 0's.

We know that the meat of what we're looking for is found in the `DllMain()` function, which since rebase, is now located at `0x6Fb817C2` which we can go look for in x32dbg and jump to it using CTRL+G.

You can press G to get graph mode on the CPU tab.

F2 will set a breakpoint.

Since we don't want to have to keep waiting for 2000 ms, we can go to the address of the main decryption method, `0x6FB817E0`, and then right click it and press "Set new origin here"

We see that part of the encryption and decryption method includesd loading the encrypted values into `eax` and then looping over it, subtracting 4 from the value of each byte one at a time, incrementing `edx` by one each loop. Once `edx` is the same value as `ecx` (which we learned that `ecx` is the length of the encrypted data via `sub ecx, esi` where `mov ecx 6FB8178B` and `move esi 6FB81000`)

### Extracting memory to a new dll output file

To extract a memory dump from x32dbg, go to *Plugins -> Scylla* and pick the active process, and corresponding dll. Make sure `OEP` has the correct address of the `EntryPoint` and then click *IAT Autosearch* and make sure it finds the correct Virtual Address and size (in this case it's `0x6FB87FFC` and size is `0x000000EC`) now you can also press *Get Imports* to see a list of all imports from kernal32.dll. Press *Dump* to save another DLL file from what is in memory.

### Analysis of 22CB (`thinprobe.exe`)

#### The FAR part 
* First open in FAR, look at header information by going into Hex mode and clicking the shortcut for the header.
* Then press alt+f6 to search for strings, f9 to create a filter like `????????*` to only get long strings. We see some info about it possibly being a self-extracted archive.
* We can exit out of it, and make a copy of the file using F5, rename it with a .zip extension and go into it to see what is inside of it. We see `thinhostprobe.dll` and `thinprobe.exe`. We can hold shift and use arrows to select them press F5 to move them out of the archive.
* Once the files are out of the archive, we can view the properties and view the certs on the file by highlighting it, pressing ctrl+A for file attributes, then p for properties. We see that it has a valid code signing certificate from Symantec, signed in 2007, valid through 2010.
* Open the `thinprobe.exe` file, change to hex mode by pressing F4, then press F8 to view header info, followed by F7 to view imports.
##### The IDA part
* Open thinhostprobe.dll in IDA and press Shift+F5 to open the list of applied libraries in the Signatures window, make sure that Microsoft Visual C/.net 32 bit runtime (`vc32rtf`) is being imported, this way it highlights what methods are runtime library methods vs which ones are custom.
* We see in the decryption method that there's a wait time of 10 seconds before the malware continues to execute
#### The x32dbg part
* Opening in x32dbg, we can look at the memory map to see where the entry point is, and see where we should rebase IDA. For us it's at 6132. So we can go back to IDA and Edit -> Segments -> Rebase
* Now we can go to the start of the malware code, in the CPU tab at 17CE by pressing CTRL+G for jump, and typing in 613217CE, press F2 to make a breakpoint there.
* In IDA we know that the decryption methid lives at 14BD, so we can go to x32dbg and jump to address CTRL+G 613214DB and execute until we hit that breakpoint
	* We can also patch the dll to make the wait time a noop all together, or change the time it waits, etc.
* We see that in the decrypt method at 14DB, the first three lines prepare the stack, and then we get to the fcmovbe method which pops `ebx` and if we look at the x32dbg stack, we'll see that the value of `ebx` at this point is `613214C3` which is the address of the `fcmovbe` instruction.
![[Screenshot 2023-01-14 at 6.11.49 PM.png]]
* The next instruction moves 673CF4 into edi, this is most likely a decryption constant.
* Followed by `sub ecx, ecx` which is the equivelant of an xor, it's a way to make a register be 0, although doing it with a subtraction method is slower than xor with itself.
* Then we establish a counter and move the value `B7` into the loweer two bytes of ecx with `mov cx, 0B7h`, `sub ebx, -4` (signed) which is -(-4) = +4 to ebx, then `xor [ebx+22], edi` which we can use the IDA evaluate (shift+/) to figure out what address this would be:
![[Screenshot 2023-01-14 at 6.40.46 PM.png]]
![[Screenshot 2023-01-14 at 6.43.55 PM.png]]
* Once we get past the xor method, where it displays that there will be something pointing to 14DD, we see that a loop method appears which wasn't visible originally in IDA:
![[Screenshot 2023-01-14 at 6.58.02 PM.png]]
* So this loop is going through and changing the values of EBX for every loop, we can see this happen in real time by stepping through it and right clicking on the EBX register, and clicking *Follow in Dump*
* Once we start looping we see the very next address that is `call`'d is 61321665


# Questions
* Don't understand: How does VA and Size get calculated in the Scylla window when dumping memory? The address doesn't seem to point anywhere??
* What's the difference between software and hardware breakpoints? ([OALabs](https://www.youtube.com/watch?v=WthvahlAYFY&t=1236s&ab_channel=OALabs))