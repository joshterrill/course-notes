
### Scripting

### Analyzing the first sample
1. Delphi function variables are stored in the order eax, edx, then ecx, then on the stack. The return value is always stored in eax.
2. Compiled delphi functions from developer code are always at the end of the code base
3. ASLR is a security protection with windows that allows the binary to be loaded anywhere in memory, we can use `setddlcharacteristics -d ./binary` to remove ASLR from the file, then open it in x32dbg.
4. We can find the first non-obfuscated function created by a developer by scrolling to the bottom of the functions list and looking a name called `_TForm1_FormCreate`. We see in this function, there's a string called `_str_Xnseeitm_i_wX.Text` which if we go to the definition, we a variable with 3 parts, we can look at these three parts by going to the *Structures* tab and finding out string. We see the parts that make it up are `_top`, `Len`, and `Text` so in this case, the text of the string would be the third part, which is: *Xnseeitm 7F i~wX*
5. If we load this address in x32dbg, set a breakpoint on it at 00476C32, we can follow the dumps of the variables going into the function at 475610 by right clicking on 476C32, and following in dump `ebp-4` and then right clicking on 476C4A and following `eax` in dump 2. 
7. After we pass over the function call at 476C3C calling a function at 475610, we get a value in edx called `\\merciwizard\\` which we can follow by right clicking on the dump values of `epb-4` in Dump 1 and "Follow dword in current dump", we see `\merciwizard\` so this function call is one where garbage goes in, and a string comes out, so it's most likely a string decryption function. We can write some python code to mimic the decryption.
8. Going into the function, we can start to rename the variable names. eax=the input string, we know that edx was 0, but based on IDA's naming convention, it looks like it's also a string, so for now we can do edx=string_2, and lastly, ecx is the output, the third argument, so ecx=output
9. In IDA if we look at the beginning of the string decode function we see that it calls into another function at 0047562D, going into this function we see it starts by doing `mov edx, [eax-8]`, the negative offset is something that is being done because the structure of the string object has 3 parts, so starting at offset -8 means that it's  starting at the `.Text` part of the string. In the function it then increments that value, stores it, and returns. We can make this a bit more readable by selecting the 8, and pressing T to go to the *Structure Offsets* screen, and scrolling down to our *_string* method.
10. Moving along the graph, we see the reference to string_2 gets compared to 0, if it is 0 (which it is by default due to xor'ing when passed in), it will go to the next graph and get assigned to a string called `dc67f@_$....`
11. Then we see a call to an unknown_libname_164 function that has a bunch of crazy stuff in it. We can reset our breakpoint in x32dbg to be on this call at 0047566F to see what it does, then restart the program. When it breaks on that function, we see right above it the string in eax that is getting passed into it at ebp-8 wich right now is equal to the string we saw above, dc67f@... if we modify the string by highlighting the dump text, right click > binary > edit, to have spaces and step over the function, we see it comes out with the same thing, only spaces removed. So this function is like a strip, we can rename it in IDA to that.
12. The second unknown function is a simple one that looks like it checks the string object at position eax-4, which is the middle paramter of the string object, or the length of the string
13. The next function called sub_427EE8 looks like it compres eax to edx, and if eax is greater, it returns, if it's less, it moves edx into eax. This is like a "find min" function
14. We can keep doing this and write our own python code that decodes the strings
```python
def decode_str(s, key=b"dc67f@#$%hlsdfg"):
	# first we do the strip
	key = key.replace(b" ", b"")
	# then we do the loop over the characters
	key = bytes(key[i] & 0x1F for i in range(len(key)))
	results = bytes(s[i] ^ key[i % len(key)] for i in range (len(s)) if s[i] != 0xE0)
	print(results)
decode_str(b"Xnseeitm\x7Fi~wX") # b'\\merciwizard\\'
```

Now we can use IDA scripting to automatically decode all strings in the app, by pressing Shift+F2 to open the *Execute Script* window. We can use the IDA python API to use our decode_str method and getting the values of all strings from the  IDA decode algorithm, and add a comment with the decoded strings like this:

![[ida-python-scripting-code.png]]![[ida-python-scripting-output.png]]
And we can press X on the method to get all xrefs, along with all of our decoded string comments in one place:
![[ida-python-scripting-xrefs.png]]
In this case, the likely C2 is http://referfile.com/Mieux....

