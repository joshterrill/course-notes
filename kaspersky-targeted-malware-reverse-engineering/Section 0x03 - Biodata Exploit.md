## Biodata Exploit History
The attack used two different exploits, one being an exploit in a known rtf format which was a vulnurable document parser, the other being a 0-day in InPage, which is a text processor mainly used with Arabic speaking users. It used downloaders, and several versions of keyloggers and backdoors, mostly written in Delphi and Visual Basic. Nearly 40 different PE files were discovered.

## Tricks in exploits with `FS:[]`
* One method of obfuscating the real entrypoint of malware is to use a method called *NOP sliding* where it inserts a bunch of NOP operatrions (90) in between real instructions. NOP is commonly used, though any insutrction that doesn't change the execution flow would also do. To search for this, we can press ALT+B for binary search and do a search for a few NOP operations in a row, say 90 90 90.
	* You can do this on hex view or IDA view, if you're in IDA view, likely you'll come across some data where the NOP is inside, once you get to it, press D to turn the dword into raw bytes
	* We see that if we search for 90 90 90 90, we come across some bits of strings, `*PPicts14ba069` which might lead us to something down the road, so we take note of it.
* It is helpful, especially when looking at byte code, to show the op codes, so we can go to Options -> General -> show 6 opcodes, and click show Stack Pointer and autocomments.
* Once we turned the readable string back into a string, we can turn the reste of the code below it after the NOP's back into code with the C shortcut

![IDA after NOP slide](ida-after-nop-slide.png)

* Reading through the code above, we first add 28h (40) to edi, which we don't have a clue about yet, then we push edi to the stack. Then we make eax 0 but xor'ing it with itself, then we push it to the stack. From there we take the fs segment at position 0 and move esp (which is an address pointer value) into it. Now we must understand what fs at offset 0 is.
	* FS in windows internals is responsibe for the windows thread block: https://learn.microsoft.com/en-us/windows/win32/api/winternl/ns-winternl-teb
	* A hint was given to look at this struct: https://www.nirsoft.net/kernel_struct/vista/NT_TIB.html which indicates offset 0 is the `PEXCEPTION_REGISTRATION_RECORD`, which if we go deeper into it, we see two fields (the two values that were pushed onto the stack from above), which are equal to `eax=PEXCEPTION_REGISTRATION_RECORD NEXT` and `edi=PEXCEPTION_DISPOSITION HANDLER`. Assembly is first in, last out, meaning the order of parameters going up from the function would read left to right as incoming parameters.
	* We could also add vc32rtf signatures and win7 type libraries to the project, then go to the *Structures* tab and add a general structure called `NT_TIB`
* In modern addressing models, segment register aren't too important. But one of them, the FS segment register is used in shellcode. 
* In the FS segment, the registry processor keeps the pointer on the current Thread Information Block (TIB)
	* The exploit has to be position independent
	* The address of libraries and functions from the process address space could be obtained from there
	* We can also find the exception handlers chain at FS offset 0
* After analyzing the code above, we can turn the rest of the code below it back into code by pressing C and we see another NOP slide all the way from 127C to 12B8 where we have more code, and then another short NOP slide to an `add edi, 28h` which is exactly what we saw in the first instruction, followed by a call to that address. So an address lives in edi, we add 28h to it, and then call into whatever lives there.

![IDA same code as before](ida-same-code-as-before.png)

* If we go back to the top of the code where we were just looking, now that we know edi would be the address of the handler, we can put the cursor on the first `add edi, 28h` address, press CTRL+/ to open the *Evaluate expression* dialog, and then add 0x28 to it to get the address of the handler, which is `0x126A`
	* Tip: you can also do address math evaluations in the *Jump to address* dialog by pressing G and go straight there
* This method has a return before it and has a return after it, so it seems likely that this would be a function. We can type P in IDA to turn it into it's own function, and then N to rename it to something like FUN_SEHANDLER.
* In this new FUN_SEHANDLER method, we see many `mov` and `xor` instructions, followed by an `add [edx+ebx], eax`. If we want to find out what is at this address, we can apply the signature for the SEHandler. We can do this by SHIFT+F9 to go to structures, hit INSERT to add a new one, and choose *Context*, then we can highlight 1274, press T to pull up the list of structures, and assign the *Context* structure to what was `bl 9Ch` at 1274.
* Moving down the assembly in the original code, we come to 1254 where we have `cmp edx, [edi]`, this compares edx with edi, which is going to be 0 from being xor'd from earlier, so this is going to trigger the exception handler to get called, which adds 1000 RVA, which moves tot he next memory page.
* What would end up happening, is the malicious document would  stop executing here, and they would implement their own malicious exception handler that would let them execute their own code.
* Next, we move past the next step of NOP's and get to 1243, where we have some similar code being executed as we've seen above and we see 28h get added to edi, eax is 0'd out, then we move esp into eax, and `644E754Ch` which as a string, is:  `dNuL` into edx (Press R to convert hex to character, in this case it's not a literal string). Starting with the last byte first because of the endienness of the intel platform, this would be `LuNd`, and edi gets 0'd out.
* Then we come to the search cycle, where we compare `edx` (LuNd) with edi (just added 28h), if they were found, it jumps, if not, edi is incremented, and the loop occurs again
* Once the cmp is true and LuNd is found, it checks for it being found again by adding 4 to edi, checking edx, and then jumping or incrementing and looping again. In this case, it would be looking for LuNdLuNd which is found referenced at address 0x34400.
* Going to the next function, converting the code using C and then turning it into a function with P, we come across `mov edi, fs:[ecx+30h]` which is `fs` at index 30. We know by looking at the TIB structure: https://en.wikipedia.org/wiki/Win32_Thread_Information_Block that `fs[30]` appears to be the Process Environment Block (PEB: https://en.wikipedia.org/wiki/Process_Environment_Block) then someone references within that are used, 0Ch and 1Ch which are PEB_LRD_DATA and FastPebLock (https://www.travismathison.com/posts/PEB_TEB_TIB-Structure-Offsets/ or https://www.geoffchappell.com/studies/windows/km/ntoskrnl/inc/api/pebteb/peb/index.htm)

# IDA PEB Structure

By copying the typedef structure definition of `PEB_LDR_DATA` from here: http://undocumented.ntinternals.net/

```
typedef struct _PEB_LDR_DATA {

  ULONG                   _Length_;
  BOOLEAN                 _Initialized_;
  PVOID                   _SsHandle_;
  LIST_ENTRY              _InLoadOrderModuleList_;
  LIST_ENTRY              _InMemoryOrderModuleList_;
  LIST_ENTRY              _InInitializationOrderModuleList_;

} PEB_LDR_DATA, *PPEB_LDR_DATA;
```

We can go into _Local Types_ in IDA and add the structure.

TODO: finish this section

# Questions
Q1. Should malefactors use only NOPs/0x90 in the shellcodes’ slides?
*No, any instructions, which don't change the execution flow would fit.*

Q1. Could you please determine the field name at this offset 0 in TIB?
*ExceptionList*

Q1. We expect “LuNdLuNd” somewhere in the same process and virtual address space. This value is in the same document, could you find the corresponding starting address? _Please provide the answer with standard 0x hexadecimal prefix without leading zeros._
*`0x34400`*

Q1. To which famous system library could the functions address resolving code refer?
_kernel32_

Q2. For which function code in the one more cycle at 0x34443 is searching?
_GetProcAddress_

### Quiz
* Open new binary up, look for NOP slide using *Binary Search (alt+b)* `90 90 90`, then look at *Hex View* to see if it's near anything that looks interesting. Go to the interesting string around 1230, press C to make it look like code
![[nop-slide-quiz-1.png]]

We see after the NOP slid that it adds some offset to EDI and then calls the offset, maybe this is a possible starting point for the actual code. But without the initial value of EDI, we don't know what it's going to do. So if we pull up the hex view and look around this area, we see some interesting readable strings:

![[biodata-quiz-2.png]]

If we navigate back to the assembly view, turn all the code into undefined by pressing U, when scrolling around, we see the strings in there and can turn them into readable string variables by pressing A.

![[biodata-quiz-3.png]]

And right below that, we see a NOP operation, so we can try to turn it into code by pressing C:

![[biodata-quiz-4.png]]

* We see similar instructions from before:
```
nop
add edi 28h
push edi
xor eax, eax
push eax
mov fs:[eax], esp
mov edx, '6872' #36383732h
xor edi, edi
```

The reason we didn't see this directly before is because there's only one NOP between the strings and the actual code. 

We can see where EDI would go by highlighting `seg:000:00001243`, pressing G for jump address, and then adding the 28h offset to it by doing `0x00001243+0x28`:

![[biodata-quiz-5.png]]

This brings us to `seg000:000126B` we can press C to turn it into code, and then P to turn it into a function. Rename the function to `handler`.

So after returning to the original code, pressing P to to turn it into a function, we see the comparison between `edx` and stack pointer `[edi]`, and there are a couple different searches, all adding values up and doing comparisons.

![[biodata-quiz-7.png]]

Starting at 1254, we have a comparison, `cmp edx, [edi]`, if it matches, it jumps to another method, if not, it increments and repeats. It's checking for the existence of '6872' (`36383732h`), so once it gets there, it goes to the next method and adds 4 bytes to edi, and then does another search sequence.

* We can search for the bytes of the comparison, `32 37 38 36` in the byte search (alt+b) and see that we're taken too a block of assembly at 1c00, we can press D to turn it all into individual bytes, do byte search again, and we come to 1e00 which has the full egg string, we can press A to turn it into a string and rename it "egg"
	* Since we found the egg, looking at the instructions from earlier, we can be sure that right below the egg is where the actual shellcode that does the decryption is going to start. We see that the instructions immediately after the egg at address 1e08 can be turned into code gives us the following:
```
nop
nop
fldpi
fstenv byte ptr [esp-0ch]
pop edi
lea ecx, [edi+19h]
mov edx, 2d4h

// loc_1e1a
not byte ptr [ecx]
xor byte ptr [ecx]
inc ecx
dec edx
jnz short loc_e11a
bound ebx, [edx+6322d837h]
fsub dword ptr ds:5f25d85fh
```
We see here that edi is popped onto the stack and then we have an address pointer put in ecx at edi+19h. We can go to edi at 1e11 and use the address jump of key G to add 0x1e11+0x19 to come to the fsub instruction at the bottom of the code at 1e29. We can press D to turn all this code into the individual bytes, then search for the edi+19h again, and we come to address 1e2a. So starting at this address at 1e2a, we'll store a reference to it, and then use the xor constant to unpack the bytes, incrementing by 1 ecx each time, then xoring by constant, over and  over.

Q1. Now using your knowledge, please analyze 729194d71ed65dd1fe9462c212c32159 in your samples directory. What is the full egg this time?
_27862786_

Q2. From which address/offset the execution would continue after the egg hunter would find the value?
_Please provide the answer with standard 0x hexadecimal prefix without leading zeros._
_0x1E08_

Q3. What is the XOR key for the next stage decrypting?  
_Please provide the answer with standard 0x hexadecimal prefix without leading zeros._
_0xAC_

# Further Reading
* https://www.geoffchappell.com/studies/windows/km/ntoskrnl/inc/api/pebteb/peb/index.htm\


# TODO
* Look into the `fs:[]` register values more
